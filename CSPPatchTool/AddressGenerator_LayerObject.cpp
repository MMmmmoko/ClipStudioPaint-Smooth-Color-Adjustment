#include"AddressGenerator.h"
#include"DllInject.h"
#include<SDL3/SDL.h>



void AddressGenerator::PushLayerObjectAddr()
{
	//图层操作所需要的指针
	SDL_Log("Start Find LayerObject Addresses...");

	//图层/图层组基址/函数调用等基址
	{
		uint8_t layerObjectBaseAddrFeature[] = {


	0x40,0x53,0x48,0x83,0xEC,0x20,
	0x48,0x83,0x3D,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,0x00,
	0x48,0x8B,0xD9,0x74,0x36,0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
	0x8B,0xC8,0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
	0x85,0xC0,0x75,0x2E,0x48,0x8B,0xCB
		};


		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectBaseAddrFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectBaseAddrFeature, sizeof(layerObjectBaseAddrFeature)))
			{
				SDL_Log("LayerObject Base Addr Finded.");
				uint32_t addrOff = *(uint32_t*)(_codeMem + i + 9);
				addrJson["CspAddressRVA"]["LayerObject_Base"] = _VA + i + 9 + 5 + addrOff;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject Base Addr Not Found!");

	}



	//图层选择函数的基址
	{
		uint8_t layerObjectSelectThisLayerFuncFeature[] = {

0x48,0x89,0x5C,0x24,0x18,0x55,0x56,0x57,0x41,0x54,0x41,0x55,0x41,0x56,0x41,
0x57,0x48,0x8D,0xAC,0x24,0xE0,0xFE,0xFF,0xFF,0x48,0x81
,0xEC,0x20,0x02,0x00,0x00,
0x48,0x8B,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
0x48,0x33,0xC4,0x48,0x89,0x85,0x10,0x01,
0x00,0x00,0x44,0x89,0x4C,0x24,0x28,0x41,
0x8B,0xD8,0x4C,0x8B,0xF2,0x4C,0x8B,0xF9,
0x48,0x89,0x4C,0x24,0x60,0x48,0x89,0x54,
0x24,0x68,0x48,0x8B,0x01,0x48,0x89,0x44,
0x24,0x30,0x48,0x8B,0x49,0x08,0x48,0x89,0x4C,0x24,0x38
		};
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectSelectThisLayerFuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectSelectThisLayerFuncFeature, sizeof(layerObjectSelectThisLayerFuncFeature)))
			{
				SDL_Log("LayerObject SelectThisLayer Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_SelectThisLayer_Func"] = _VA + i;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject SelectThisLayer Func Not Found!");
	}

	//图层复制函数的基址
	{
		uint8_t layerObjectDuplicateFuncFeature[] = {
		0X48,0x89,0x5C,0x24,0x10,0x48,0x89,0x7C,0x24,0x18,
		0x55,0x48,0x8D,0x6C,0x24,0xA0,0x48,0x81,0xEC,
		0x60,0x01,0x00,0x00,
		0x48,0x8B,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
		0x48,0x33,0xC4,0x48,0x89,0x45,0x50,0x48,0x8B,
		0xD9,0x48,0x89,0x4C,0x24,0x50,0x48,0x8B,0x01,
		0x48,0x89,0x44,0x24,0x30,0x48,0x8B,0x49,0x08,
		0x48,0x89,0x4C,0x24,0x38,0xBF,0x01,0x00,0x00,
		0x00,0x48,0x85,0xC9,0x74,0x07
		};
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectDuplicateFuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectDuplicateFuncFeature, sizeof(layerObjectDuplicateFuncFeature)))
			{
				SDL_Log("LayerObject Duplicate Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_Duplicate_Func"] = _VA + i;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject Duplicate Func Not Found!");

	}


	//图层设置可见性
	{

		uint8_t layerObjectSetVisibleFuncFeature[] = {
			0x48,0x89,0x5C,0x24,0x10,0x48,0x89,0x4C,0x24,0x08,0x55,0x56,0x57,0x41,0x54,0x41,0x55,0x41,0x56,0x41,0x57,0x48,0x8B,0xEC,0x48,0x83,0xEC,0x70,0x4D,0x8B,0xE0,0x44,0x8B,0xEA,0x4C,0x8B,0xF1,0x48,0x8B,0x09,0x48,0x85,0xC9,0x75,0x3D
		};
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectSetVisibleFuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectSetVisibleFuncFeature, sizeof(layerObjectSetVisibleFuncFeature)))
			{
				SDL_Log("LayerObject SetVisible Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_SetVisible_Func"] = _VA + i;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject SetVisible Func Not Found!");

	}



	//获取菜单参数2
	{

		uint8_t layerObjectGetMenuParam2FuncFeature[] = {
	0x40,0x53,0x48,0x83,0xEC,0x20,//6
	0x48,0x8D,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,//7
	0x48,0x8B,0xD9,0x48,0x89,0x01,0x33,0xC0,//8
	0x48,0x89,0x41,0x08,0x48,0x89,0x41,0x10,//8
	0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,0x48,0x8B,0xC3,0x48,0x83,0xC4,0x20,0x5B,0xC3
		
		
	//		40,53,48,83,EC,20,
	//48,8D,05,??,??,??,??,
	//48,8B,D9,48,89,01,33,C0,
	//48,89,41,08,48,89,41,10,
	//E8,??, ??,??,??,48,8B,C3,48,83,C4,20,5B,C3
		};
		//上面的特征会找到两个函数，需要另一个feature来确定上方的一部分通配符数值
		uint8_t layerObjectGetMenuParam2InternalFuncFeature[] =
		{
			0x48,0x89,0x5C,0x24,0x10,0x48,0x89,0x6C,0x24,0x18,0x57,0x48,0x83,0xEC,0x20,0x48,0x8B,0x59,0x10,0x33,0xED,0x48,0x89,0x69,0x08,0x48,0x8B,0xF9,0x48,0x89,0x69,0x10,0x48,0x85,0xDB,0x74,0x37
		};
		//先寻找下方特征
		bool success = false;
		uint32_t resultValue = 0;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectGetMenuParam2InternalFuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectGetMenuParam2InternalFuncFeature, sizeof(layerObjectGetMenuParam2InternalFuncFeature)))
			{
				success = true;
				resultValue = i;
				break;
			}
		}

		if (success)
		{
			success = false;
			for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectGetMenuParam2FuncFeature); i++)
			{
				if (_MatchFeatureCode(_codeMem + i, layerObjectGetMenuParam2FuncFeature, sizeof(layerObjectGetMenuParam2FuncFeature)))
				{
					//如果匹配成功，需要在确认第二个通配符数值
					uint32_t calcAddress = i + 34 + *(uint32_t*)(_codeMem + i + 30);

					if (calcAddress == resultValue)
					{
						SDL_Log("LayerObject GetMenuFuncParam2 Func Finded.");
						addrJson["CspAddressRVA"]["LayerObject_GetMenuFuncParam2_Func"] = _VA + i;
						addrJson["CspAddressRVA"]["LayerObject_ReleaseMenuFuncParam2_Func"] = _VA + i+0x30;
						success = true;
					}
					break;
				}
			}
		}
		else
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject GetMenuFuncParam2 Func Not Found!");


	}
	//获取菜单参数3
	{
		uint8_t layerObjectGetMenuParam3FuncFeature[] = {
0x40,0x53,0x48,0x83,0xEC,0x20,
0x48,0x8D,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
0x48,0x8B,0xD9,0x48,0x89,0x01,0x48,0x83,0xC1,0x08,
0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
0x33,0xC0,0x48,0x89,0x43,0x38,0x48,0x89,0x43,
0x40,0x48,0x8B,0xC3,0x48,0x83,0xC4,0x20,0x5B,
0xC3,0xCC,0x48,0x89,0x5C,0x24,0x08,0x57,0x48,
0x83,0xEC,0x20,0x48,0x8B,0x59,0x08,0x48,0x8B,
0xF9,0x48,0x85,0xDB
		};
	
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectGetMenuParam3FuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectGetMenuParam3FuncFeature, sizeof(layerObjectGetMenuParam3FuncFeature)))
			{
				SDL_Log("LayerObject GetFuncParam3 Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_GetMenuFuncParam3_Func"] = _VA + i ;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject GetMenuFuncParam3 Func Not Found!");
	}
	//释放菜单参数3
	{
		uint8_t layerObjectReleaseMenuParam3FuncFeature[] = {
		0xFF,0x15,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,//6
		0xCC,0xCC,0xCC,0xCC,0xCC,//5
		0xCC,0xCC,0xCC,0xCC,0xCC,//5
		0xCC,0xCC,0xCC,0xCC,//4
		0x48,0x89,0x5C,0x24,0x10,0x57,0x48,0x83,0xEC,0x20,
		0x48,0x8D,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
		0x48,0x8B,0xF9,0x48,0x89,0x01,0x48,0x8B,0x59,0x40,
		0x48,0x85,0xDB,0x74,0x37,0x48,0x89,0x74,0x24,0x30,
		0xBE,0xFF,0xFF,0xFF,0xFF,0x8B,0xC6,0xF0,0x0F,0xC1,
		0x43,0x08,0x83,0xF8,0x01,0x75,0x1C,0x48,0x8B,0x03,
		0x48,0x8B,0xCB,0xFF,0x50,0x08,0xF0,0x0F,0xC1,0x73,
		0x0C,0x83,0xFE,0x01,0x75,0x09,0x48,0x8B,0x03,0x48,
		0x8B,0xCB,0xFF,0x50,0x10,0x48,0x8B,0x74,0x24,0x30,
		0x48,0x8D,0x4F,0x08,0x48,0x8B,0x5C,0x24,0x38,0x48,
		0x83,0xC4,0x20,0x5F
		};
	
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectReleaseMenuParam3FuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectReleaseMenuParam3FuncFeature, sizeof(layerObjectReleaseMenuParam3FuncFeature)))
			{
				SDL_Log("LayerObject ReleaseFuncParam3 Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_ReleaseMenuFuncParam3_Func"] = _VA + i + 20;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject ReleaseMenuFuncParam3 Func Not Found!");
	}


	//图层上移1层
	{
		//因为搜出来了两个函数，所以选择了这里尝试了向上搜索最近函数，这之间的空间能有一些区分
		//后面的特征基本和“图层下移一层”是一样的
		uint8_t layerObjectMoveUpFuncFeature[] = {
		0xC3,0xCC,0xCC,0xCC,0xCC,
		0xCC,0xCC,0xCC,0xCC,0xCC,
		0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
		0x48,0x89,0x5C,0x24,0x18,0x55,0x56,0x57,0x41,0x56,
		0x41,0x57,0x48,0x8D,0x6C,0x24,0xB0,0x48,0x81,
		0xEC,0x50,0x01,0x00,0x00,
		0x48,0x8B,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
		0x48,0x33,0xC4,0x48,0x89,0x45,0x40,0x48,0x8B,0xFA,
		0x4C,0x8B,0xF9,0x48,0x89,0x4C,0x24,0x60,0x48,0x8D,0x54,0x24,0x50,0x48,0x8B,0x09
		};
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectMoveUpFuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectMoveUpFuncFeature, sizeof(layerObjectMoveUpFuncFeature)))
			{
				SDL_Log("LayerObject MoveUp Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_MoveUp_Func"] = _VA + i+16;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject MoveUp Func Not Found!");	
	}
	//图层下移1层
	{
		//因为搜出来了两个函数，所以选择了这里尝试了向上搜索最近函数，这之间的空间能有一些区分
		//后面的特征基本和“图层下移一层”是一样的
		uint8_t layerObjectMoveDownFuncFeature[] = {
0xC3,0xCC,0xCC,0xCC,0xCC,
0xCC,0xCC,0xCC,0xCC,0xCC,
0x48,0x89,0x5C,0x24,0x18,0x55,0x56,0x57,0x41,0x56,
0x41,0x57,0x48,0x8D,0x6C,0x24,0xB0,0x48,0x81,
0xEC,0x50,0x01,0x00,0x00,
0x48,0x8B,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
0x48,0x33,0xC4,0x48,0x89,0x45,0x40,0x48,0x8B,0xFA,
0x4C,0x8B,0xF9,0x48,0x89,0x4C,0x24,0x60,0x48,0x8D,0x54,0x24,0x50,0x48,0x8B,0x09
		};
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectMoveDownFuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectMoveDownFuncFeature, sizeof(layerObjectMoveDownFuncFeature)))
			{
				SDL_Log("LayerObject MoveDown Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_MoveDown_Func"] = _VA + i+10;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject MoveDown Func Not Found!");	
	}
	//图层向下合并
	{
		//因为搜出来了两个函数，所以选择了这里尝试了向上搜索最近函数，这之间的空间能有一些区分
		//后面的特征基本和“图层下移一层”是一样的
		uint8_t layerObjectMergeDownFuncFeature[] = {
//0x48,0x89,0x5C,0x24,0x18,0x55,0x56,0x57,0x41,
//0x54,0x41,0x55,0x41,0x56,0x41,0x57,0x48,0x8D,
//0xAC,0x24,0xA0,0xF6,0xFF,0xFF,0x48,0x81,0xEC,0xA0,0x0A,0x00,0x00,
//0x48,0x8B,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
//0x48,0x33,0xC4,0x48,0x89,0x85,0x50,0x09,0x00,0x00,
//0x44,0x89,0x4D,0xDC,0x44,0x89,0x45,0xD8,0x48,0x89,
//0x55,0x70,0x48,0x8B,0xF1,0x48,0x89,0x8D,0x00,0x06,
//0x00,0x00,0x4C,0x8B,0xAD,0xC0,0x09,0x00,0x00,0x48,0x8B,0x09



0x48,0x89,0x5C,0x24,0x20,0x55,0x56,0x57,0x41,
0x56,0x41,0x57,0x48,0x8D,0xAC,0x24,0x50,0xFF,
0xFF,0xFF,0x48,0x81,0xEC,0xB0,0x01,0x00,0x00,
0x48,0x8B,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
0x48,0x33,0xC4,0x48,0x89,0x85,0xA8,0x00,0x00,0x00,
0x4D,0x8B,0xF8,0x44,0x8B,0xF2,0x48,0x8B,0xD9,0x48,
0x89,0x4C,0x24,0x60,0x48,0x8B,0x01,0x48,0x89,0x44,
0x24,0x40,0x48,0x8B,0x49,0x08,0x48,0x89,0x4C,0x24,
0x48,0xBF,0x01,0x00,0x00,0x00,0x48,0x85,0xC9,0x74,0x07


//48,89,5C,24,18,55,56,57,41,
//54,41,55,41,56,41,57,48,8D,
//AC,24,A0,F6,FF,FF,48,81,EC,A0,0A,00,00,
//48,8B,05,??, ??,??,??,
//48,33,C4,48,89,85,50,09,00,00,
//44,89,4D,DC,44,89,45,D8,48,89,
//55,70,48,8B,F1,48,89,8D,00,06,
//00,00,4C,8B,AD,C0,09,00,00,48,8B,09
		};
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectMergeDownFuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectMergeDownFuncFeature, sizeof(layerObjectMergeDownFuncFeature)))
			{
				SDL_Log("LayerObject MergeDown Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_MergeDown_Func"] = _VA + i;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject MergeDown Func Not Found!");	
	}

	//图层向下合并跳过对话框的修改点（修改为mov eax,4）
	{

		uint8_t layerObjectMergeDownPatchAddrFeature[] = {
		0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
		0x8B,0xD8,0x48,0x8D,0x8D,0xD0,0x06,0x00,0x00,
		0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
		0x90,0x48,0x8D,0x8D,0x10,0x07,0x00,0x00,
		0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
		0x90,0x48,0x8D,0x8D,0x50,0x07,0x00,0x00,
		0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
		0x90,0x48,0x8D,0x8D,0x90,0x07,0x00,0x00,
		0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
		0x90,0x48,0x8D,0x8D,0xD0,0x07,0x00,0x00,
		0xE8,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
		};

		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectMergeDownPatchAddrFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectMergeDownPatchAddrFeature, sizeof(layerObjectMergeDownPatchAddrFeature)))
			{
				SDL_Log("LayerObject MergeDown Patch Addr Finded.");
				addrJson["CspAddressRVA"]["LayerObject_MergeDownPatchAddr"] = _VA + i;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject MergeDown Patch Addr Not Found!");
	}

	//新建图层
	{
		//因为搜出来了两个函数，所以选择了这里尝试了向上搜索最近函数，这之间的空间能有一些区分
		//后面的特征基本和“图层下移一层”是一样的
		uint8_t layerObjectMergeDownFuncFeature[] = {
0xC3,0xCC,0xCC,0xCC,0xCC,
0x48,0x89,0x5C,0x24,0x10,0x48,0x89,0x7C,
0x24,0x18,0x55,0x48,0x8D,0x6C,0x24,0x80,
0x48,0x81,0xEC,0x80,0x01,0x00,0x00,
0x48,0x8B,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
0x48,0x33,0xC4,0x48,0x89,0x45,0x70,0x48,0x8B,0xD9,
0x48,0x89,0x4C,0x24,0x68,0x48,0x8B,0x01,0x48,0x89,
0x44,0x24,0x28,0x48,0x8B,0x49,0x08,0x48,0x89,0x4C,
0x24,0x30,0xBF,0x01,0x00,0x00,0x00,0x48,0x85,0xC9,0x74,0x07
		};
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectMergeDownFuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectMergeDownFuncFeature, sizeof(layerObjectMergeDownFuncFeature)))
			{
				SDL_Log("LayerObject CreateLayer Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_CreateLayer_Func"] = _VA + i+5;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject CreateLayer Func Not Found!");
	}
	//合并所选图层
	{
		//因为搜出来了两个函数，所以选择了这里尝试了向上搜索最近函数，这之间的空间能有一些区分
		//后面的特征基本和“图层下移一层”是一样的
		uint8_t layerObjectMergeSelectFuncFeature[] = {
0x48,0x89,0x5C,0x24,0x10,0x48,0x89,0x74,0x24,
0x18,0x48,0x89,0x7C,0x24,0x20,0x55,0x48,0x8D,
0xAC,0x24,0x40,0xFF,0xFF,0xFF,0x48,0x81,0xEC,
0xC0,0x01,0x00,0x00,
0x48,0x8B,0x05,BYTEWILDCARD, BYTEWILDCARD,BYTEWILDCARD,BYTEWILDCARD,
0x48,0x33,0xC4,0x48,0x89,0x85,0xB0,0x00,0x00,0x00,
0x48,0x8B,0xF9,0x48,0x89,0x4C,0x24,0x68,0x48,0x8B,
0x01,0x48,0x89,0x44,0x24,0x28,0x48,0x8B,0x49,0x08,
0x48,0x89,0x4C,0x24,0x30,0xBB,0x01,0x00,0x00,0x00,
0x48,0x85,0xC9,0x74,0x07
		};
		bool success = false;
		for (uint32_t i = 0; i < _codeMemSize - sizeof(layerObjectMergeSelectFuncFeature); i++)
		{
			if (_MatchFeatureCode(_codeMem + i, layerObjectMergeSelectFuncFeature, sizeof(layerObjectMergeSelectFuncFeature)))
			{
				SDL_Log("LayerObject MergeSelect Func Finded.");
				addrJson["CspAddressRVA"]["LayerObject_MergeSelect_Func"] = _VA + i;
				success = true;
				break;
			}
		}
		if (!success)
			SDL_LogError(SDL_LogCategory::SDL_LOG_CATEGORY_ERROR, "LayerObject MergeSelect Func Not Found!");
	}
}